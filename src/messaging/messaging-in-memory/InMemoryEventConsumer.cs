using Microsoft.Extensions.Logging;
using ReadModel;
using Todo.Events;

namespace Messaging.InMemory
{
    /// <summary>
    /// Class responsible for consuming events generated by aggregates using ordinary .NET events,
    /// and update the read model accordingly.
    /// </summary>
    public class InMemoryEventConsumer
    {
        private readonly ITodoListSynchronizer synchronizer;
        private readonly ILogger<InMemoryEventConsumer> logger;

        public InMemoryEventConsumer(
            InMemoryEventPublisher publisher,
            ITodoListSynchronizer synchronizer,
            ILogger<InMemoryEventConsumer> logger)
        {
            this.synchronizer = synchronizer;
            this.logger = logger;

            publisher.TodoAdded += OnTodoAdded;
            publisher.TodoRenamed += OnTodoRenamed;
            publisher.TodoCompleted += OnTodoCompleted;
            publisher.TodoIncompleted += OnTodoIncompleted;
            publisher.TodoRemoved += OnTodoRemoved;
        }

        private void OnTodoAdded(object sender, TodoAdded e)
        {
            Log(e);

            synchronizer.Add(e.Id, e.Title);
        }

        private void OnTodoRenamed(object sender, TodoRenamed e)
        {
            Log(e);

            synchronizer.Rename(e.Id, e.NewTitle);
        }

        private void OnTodoCompleted(object sender, TodoCompleted e)
        {
            Log(e);

            synchronizer.SetCompleted(e.Id, true);
        }

        private void OnTodoIncompleted(object sender, TodoIncompleted e)
        {
            Log(e);

            synchronizer.SetCompleted(e.Id, false);
        }

        private void OnTodoRemoved(object sender, TodoRemoved e)
        {
            Log(e);

            synchronizer.Remove(e.Id);
        }

        private void Log<T>(T e)
        {
            logger.LogInformation("Consume {event}", e);
        }
    }
}
